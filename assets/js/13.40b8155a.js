(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{277:function(v,_,i){"use strict";i.r(_);var s=i(13),a=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"javascript"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[v._v("#")]),v._v(" Javascript")]),v._v(" "),_("h2",{attrs:{id:"【1】console-log-0-1-0-2-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【1】console-log-0-1-0-2-掌握"}},[v._v("#")]),v._v(" 【1】console.log(0.1 + 0.2) （掌握）")]),v._v(" "),_("p",[v._v("0.1+0.2的结果不是0.3，而是0.3000000000000000004，JS中两个数字相加时是以二进制形式进行的，当十进制小数的二进制表示的有限数字超过52位时，在JS里是不能精确储存的，这个时候就存在舍入误差。")]),v._v(" "),_("h2",{attrs:{id:"【2】事件冒泡和事件捕获到底有何区别-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【2】事件冒泡和事件捕获到底有何区别-掌握"}},[v._v("#")]),v._v(" 【2】事件冒泡和事件捕获到底有何区别？（掌握）")]),v._v(" "),_("ul",[_("li",[v._v("事件冒泡：从下至上。当给有层级关系的元素的同一事件绑定方法时，触发子元素身上的事件，会像冒泡一样，依次触发父级元素相同的事件。")]),v._v(" "),_("li",[v._v("事件捕获：从上至下到指定元素。当触发子元素身上的事件时，先触发父元素，然后在传递给子元素")]),v._v(" "),_("li",[v._v("注意：addEventListener中有三个属性，第三个属性是布尔值。false为事件冒泡，true为事件捕获。")])]),v._v(" "),_("h2",{attrs:{id:"【3】js数据类型-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【3】js数据类型-掌握"}},[v._v("#")]),v._v(" 【3】JS数据类型（掌握）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("ES5：Number、String、Boolean、null、undefine")])]),v._v(" "),_("li",[_("p",[v._v("ES6：Symbol")]),v._v(" "),_("ul",[_("li",[v._v("Symbol的值是唯一的，不会重复")])])])]),v._v(" "),_("h2",{attrs:{id:"【4】简述javascript原型、原型链-有什么特点-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【4】简述javascript原型、原型链-有什么特点-掌握"}},[v._v("#")]),v._v(" 【4】简述javascript原型、原型链？有什么特点（掌握）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("原型")]),v._v(" "),_("ul",[_("li",[v._v("原型是针对函数而言的，构造函数也是一个函数。")]),v._v(" "),_("li",[v._v("在JS中，我们创建的每一个函数自带一个属性prototype，这个prototype就称之为原型，它是函数的独有属性。prototype指向一个对象，这个对象就是原型对象，原型对象内有个constructor属性，它指向当前的构造函数。")])])]),v._v(" "),_("li",[_("p",[v._v("原型链")]),v._v(" "),_("ul",[_("li",[v._v("每一个实例对象都有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有一个 __proto__属性，指向它的构造函数的原型对象，这样一层一层往上找就形成了原型链。")])])]),v._v(" "),_("li",[_("p",[v._v("特点：")]),v._v(" "),_("ul",[_("li",[v._v("原型和原型链巧妙地解决了js中实现继承的问题")]),v._v(" "),_("li",[v._v("实现继承：一个对象可以拿到另一个对象上的属性和方法，实现了数据共享、节省内存空间。")])])])]),v._v(" "),_("h2",{attrs:{id:"【5】谈谈this对象的理解-call-、apply-和bind-的区别-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【5】谈谈this对象的理解-call-、apply-和bind-的区别-掌握"}},[v._v("#")]),v._v(" 【5】谈谈this对象的理解，call()、apply()和bind()的区别（掌握）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("this指向")]),v._v(" "),_("ul",[_("li",[v._v("全局作用域中this指向window")]),v._v(" "),_("li",[v._v("函数作用域中this指向window")]),v._v(" "),_("li",[v._v("在事件绑定中的this指向事件源")]),v._v(" "),_("li",[v._v("当一个对象调用一个函数时，函数内的this指向的是这个对象")]),v._v(" "),_("li",[v._v("箭头函数内部  this指向了当前作用域的最近一级外层作用域")]),v._v(" "),_("li",[v._v("new关键字将函数作为构造函数调用时，构造函数内部的this指向新创建的对象。")])])]),v._v(" "),_("li",[_("p",[v._v("三者相同点")]),v._v(" "),_("ul",[_("li",[v._v("call、apply、bind都是用来绑定函数执行时this指向，同时可以传参，调用它们的对象必须是一个函数Function")])])]),v._v(" "),_("li",[_("p",[v._v("三者不同点：区别主要体现在传参上")]),v._v(" "),_("ul",[_("li",[v._v("call可以传多个参数，第一个参数是this指向，其余参数是要传递的参数")]),v._v(" "),_("li",[v._v("apply，有两个参数，第一个是this指向，第二个是参数数组")]),v._v(" "),_("li",[v._v("bind可以传多个参数，第一个参数是this指向，其余参数是要传递的参数。bind方法的返回值是函数，需要手动调用才会执行")])])])]),v._v(" "),_("h2",{attrs:{id:"【6】什么是闭包-为什么要用它-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【6】什么是闭包-为什么要用它-掌握"}},[v._v("#")]),v._v(" 【6】什么是闭包？为什么要用它？（掌握）")]),v._v(" "),_("p",[v._v("闭包本质就是一个函数，它是指能够读取其他函数内部变量的函数，它是将函数内外部连接起来的桥梁。只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。")]),v._v(" "),_("p",[v._v("闭包的主要作用：实现了数据的私有化，延伸了变量的作用范围。")]),v._v(" "),_("h2",{attrs:{id:"【7】简述js继承的方式-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【7】简述js继承的方式-掌握"}},[v._v("#")]),v._v(" 【7】简述js继承的方式（掌握）")]),v._v(" "),_("ul",[_("li",[v._v("混入式继承：把父类的所有方法都拷贝到子类上")]),v._v(" "),_("li",[v._v("原型式继承：只继承父类原型上的属性和方法，")]),v._v(" "),_("li",[v._v("原型链继承：继承父类构造函数里边的属性和方法，也继承父类原型上的属性和方法 缺点--不能向父类传参数")]),v._v(" "),_("li",[v._v("借用构造函数继承：可以父类传递参数 缺点--继承不了父类原型对象的方法")]),v._v(" "),_("li",[v._v("组合继承：借用构造函数继承属性+原型链继承方法")])]),v._v(" "),_("h2",{attrs:{id:"【8】深拷贝和浅拷贝的区别-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【8】深拷贝和浅拷贝的区别-掌握"}},[v._v("#")]),v._v(" 【8】深拷贝和浅拷贝的区别（掌握）")]),v._v(" "),_("ul",[_("li",[v._v("深拷贝拷贝多层，每一级别的数据都会拷贝，像数组、对象内的数据都是可以拷贝的。")]),v._v(" "),_("li",[v._v("浅拷贝只是拷贝一层，像简单数据类型可以直接拷贝，更深层次对象级别的只拷贝对象引用地址（修改对象内的属性值会相互影响）")]),v._v(" "),_("li",[v._v("es6新增方法可以浅拷贝：Object.assign(新对象,被拷贝对象)")])]),v._v(" "),_("h2",{attrs:{id:"【9】如何实现深拷贝-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【9】如何实现深拷贝-掌握"}},[v._v("#")]),v._v(" 【9】如何实现深拷贝（掌握）")]),v._v(" "),_("h2",{attrs:{id:"【10】javascript-的垃圾回收机制讲一下-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【10】javascript-的垃圾回收机制讲一下-掌握"}},[v._v("#")]),v._v(" 【10】javascript 的垃圾回收机制讲一下（掌握）")]),v._v(" "),_("ul",[_("li",[v._v("垃圾回收机制（Garbage Collection）简称GC")]),v._v(" "),_("li",[v._v("JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。")]),v._v(" "),_("li",[v._v("垃圾回收机制会自动在后台进行检查，哪些内存空间是已经没有被变量绑定的，如果存在就会标记它们，在垃圾回收执行时去释放这些标记好的内存空间的地址，这个释放并不是删除，而是告诉CPU哪些空间是可以用的，后续有新数据便会存入到里面，进行覆盖。")]),v._v(" "),_("li",[v._v("不再用到的内存，没有及时释放，就叫做内存泄露。垃圾回收机制就是防止内存泄漏的。")])]),v._v(" "),_("h2",{attrs:{id:"【11】介绍下-promise-的特性、优缺点-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【11】介绍下-promise-的特性、优缺点-掌握"}},[v._v("#")]),v._v(" 【11】介绍下 promise 的特性、优缺点（掌握）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Promise是异步编程的一种解决方案，异步转同步（调用起来像同步一样）\n它的功能：避免了异步回调的多层嵌套，把异步代码改成调用起来像同步代码。")])]),v._v(" "),_("li",[_("p",[v._v("Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)")])]),v._v(" "),_("li",[_("p",[v._v("Promise优点")]),v._v(" "),_("ol",[_("li",[v._v("统一异步 API\nPromise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。")]),v._v(" "),_("li",[v._v("Promise 与事件对比\n和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。")]),v._v(" "),_("li",[v._v("Promise 与回调对比\n解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。")]),v._v(" "),_("li",[v._v("Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如Array.prototype.map() ）。")])])]),v._v(" "),_("li",[_("p",[v._v("Promise缺点")]),v._v(" "),_("ol",[_("li",[v._v("无法取消Promise，一旦新建它就会立即执行，无法中途取消。")]),v._v(" "),_("li",[v._v("如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。")]),v._v(" "),_("li",[v._v("当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")]),v._v(" "),_("li",[v._v("Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。")])])])]),v._v(" "),_("h2",{attrs:{id:"【12】请描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【12】请描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[v._v("#")]),v._v(" 【12】请描述一下 cookies，sessionStorage 和 localStorage 的区别？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("cookie是网站为了标示用户身份而存储在用户本地终端上的数据，是加密的。")])]),v._v(" "),_("li",[_("p",[v._v("cookie数据始终在同源的http请求中携带，会在浏览器和服务器间来回传递。")])]),v._v(" "),_("li",[_("p",[v._v("sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存")])]),v._v(" "),_("li",[_("p",[v._v("存储大小")]),v._v(" "),_("ol",[_("li",[v._v("cookie数据大小不能超过4kb")]),v._v(" "),_("li",[v._v("sessionStorage和localStorage可以达到5M或更大")])])]),v._v(" "),_("li",[_("p",[v._v("有效时间")]),v._v(" "),_("ol",[_("li",[v._v("cookie可以设置过期时间，在没过期之前，一直有效，不会因窗口或浏览器的关闭受到影响")]),v._v(" "),_("li",[v._v("sessionStorage数据在当前浏览器窗口关闭后自动删除")]),v._v(" "),_("li",[v._v("localStorage浏览器关闭后数据不丢失，可以持久存储数据，除非手动删除")])])])]),v._v(" "),_("h2",{attrs:{id:"【13】简述同源策略与跨域-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【13】简述同源策略与跨域-掌握"}},[v._v("#")]),v._v(" 【13】简述同源策略与跨域（掌握）")]),v._v(" "),_("p",[v._v("同源策略是一种约定，它是浏览器最核心的也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。")]),v._v(" "),_("p",[v._v("当协议，主机，和端口号有一个不同时，就是跨域。")]),v._v(" "),_("h2",{attrs:{id:"【14】跨域解决方案-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【14】跨域解决方案-掌握"}},[v._v("#")]),v._v(" 【14】跨域解决方案（掌握）")]),v._v(" "),_("ul",[_("li",[v._v("网站跨域问题一般发生在前后端分离的架构。")]),v._v(" "),_("li",[v._v("解决方案\n"),_("ol",[_("li",[v._v("前后端部署到同一台web服务器，实现了同源策略。")]),v._v(" "),_("li",[v._v("（后端）服务器配置CORS(跨域资源共享)")]),v._v(" "),_("li",[v._v("（后端）node.js或Nginx，反向代理，把跨域改造成同域")]),v._v(" "),_("li",[v._v("（前端）将JSON升级成JSONP，在JSON的基础上，利用script 标签可以跨域的特性，加上头设置")])])])]),v._v(" "),_("h2",{attrs:{id:"【15】浏览器的事件循环-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【15】浏览器的事件循环-掌握"}},[v._v("#")]),v._v(" 【15】浏览器的事件循环（掌握）")]),v._v(" "),_("ul",[_("li",[v._v("主线程不断的重复获得任务，执行任务的过程被称为浏览器的事件循环。")]),v._v(" "),_("li",[v._v("JS语言特点是单线程，解释性语言，解释一行执行一行，也就是说同一时间只能做一件事。\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就得一直等待。")]),v._v(" "),_("li",[v._v("JS将所有任务分成两种，一种是同步任务，另一种是异步任务，异步任务又分为两种，宏任务和微任务。先执行宏任务，再执行微任务。\n"),_("ul",[_("li",[v._v("同步任务指的是，在主线程中排队执行的任务，按序执行，只有前一个任务执行完毕，才能执行后一个任务；")]),v._v(" "),_("li",[v._v("异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。")])])])]),v._v(" "),_("h2",{attrs:{id:"【16】什么是防抖和节流-有什么区别-如何实现-掌握"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#【16】什么是防抖和节流-有什么区别-如何实现-掌握"}},[v._v("#")]),v._v(" 【16】什么是防抖和节流？有什么区别？如何实现？（掌握）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("防抖或节流：通过一定的方式去限制函数的执行次数")])]),v._v(" "),_("li",[_("p",[v._v("防抖：通过setTimeout的方式，在一定的时间间隔内，将多次触发变成一次触发。如果设定的时间还没到来之前，又一次触发了事件 ，则清除之前的定时器，就重新开始延时。")])]),v._v(" "),_("li",[_("p",[v._v("节流：在一段时间内，只执行一次某个操作；过了这一段时间，还有操作的话，继续执行新的操作")])]),v._v(" "),_("li",[_("p",[v._v("区别:")]),v._v(" "),_("ul",[_("li",[v._v("节流不管事件触发多频繁，都保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数")])])]),v._v(" "),_("li",[_("p",[v._v("实现：")]),v._v(" "),_("ul",[_("li",[v._v("防抖：每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。")]),v._v(" "),_("li",[v._v("节流：每次触发事件的时候，判断当前是否存在等待执行的延时函数")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);