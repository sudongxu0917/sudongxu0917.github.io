(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{287:function(s,t,a){"use strict";a.r(t);var v=a(13),_=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[s._v("#")]),s._v(" Javascript")]),s._v(" "),t("h2",{attrs:{id:"【1】console-log-0-1-0-2-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【1】console-log-0-1-0-2-掌握"}},[s._v("#")]),s._v(" 【1】console.log(0.1 + 0.2) （掌握）")]),s._v(" "),t("p",[s._v("0.1+0.2的结果不是0.3，而是0.3000000000000000004，JS中两个数字相加时是以二进制形式进行的，当十进制小数的二进制表示的有限数字超过52位时，在JS里是不能精确储存的，这个时候就存在舍入误差。")]),s._v(" "),t("h2",{attrs:{id:"【2】事件冒泡和事件捕获到底有何区别-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【2】事件冒泡和事件捕获到底有何区别-掌握"}},[s._v("#")]),s._v(" 【2】事件冒泡和事件捕获到底有何区别？（掌握）")]),s._v(" "),t("ul",[t("li",[s._v("事件冒泡：从下至上。当给有层级关系的元素的同一事件绑定方法时，触发子元素身上的事件，会像冒泡一样，依次触发父级元素相同的事件。")]),s._v(" "),t("li",[s._v("事件捕获：从上至下到指定元素。当触发子元素身上的事件时，先触发父元素，然后在传递给子元素")]),s._v(" "),t("li",[s._v("注意：addEventListener中有三个属性，第三个属性是布尔值。false为事件冒泡，true为事件捕获。")])]),s._v(" "),t("h2",{attrs:{id:"【3】js数据类型-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【3】js数据类型-掌握"}},[s._v("#")]),s._v(" 【3】JS数据类型（掌握）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("ES5：Number、String、Boolean、null、undefine")])]),s._v(" "),t("li",[t("p",[s._v("ES6：Symbol")]),s._v(" "),t("ul",[t("li",[s._v("Symbol的值是唯一的，不会重复")])])])]),s._v(" "),t("h2",{attrs:{id:"【4】简述javascript原型、原型链-有什么特点-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【4】简述javascript原型、原型链-有什么特点-掌握"}},[s._v("#")]),s._v(" 【4】简述javascript原型、原型链？有什么特点（掌握）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("原型")]),s._v(" "),t("ul",[t("li",[s._v("原型是针对函数而言的，构造函数也是一个函数。")]),s._v(" "),t("li",[s._v("在JS中，我们创建的每一个函数自带一个属性prototype，这个prototype就称之为原型，它是函数的独有属性。prototype指向一个对象，这个对象就是原型对象，原型对象内有个constructor属性，它指向当前的构造函数。")])])]),s._v(" "),t("li",[t("p",[s._v("原型链")]),s._v(" "),t("ul",[t("li",[s._v("每一个实例对象都有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有一个 __proto__属性，指向它的构造函数的原型对象，这样一层一层往上找就形成了原型链。")])])]),s._v(" "),t("li",[t("p",[s._v("特点：")]),s._v(" "),t("ul",[t("li",[s._v("原型和原型链巧妙地解决了js中实现继承的问题")]),s._v(" "),t("li",[s._v("实现继承：一个对象可以拿到另一个对象上的属性和方法，实现了数据共享、节省内存空间。")])])])]),s._v(" "),t("h2",{attrs:{id:"【5】谈谈this对象的理解-call-、apply-和bind-的区别-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【5】谈谈this对象的理解-call-、apply-和bind-的区别-掌握"}},[s._v("#")]),s._v(" 【5】谈谈this对象的理解，call()、apply()和bind()的区别（掌握）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("this指向")]),s._v(" "),t("ul",[t("li",[s._v("全局作用域中this指向window")]),s._v(" "),t("li",[s._v("函数作用域中this指向window")]),s._v(" "),t("li",[s._v("在事件绑定中的this指向事件源")]),s._v(" "),t("li",[s._v("当一个对象调用一个函数时，函数内的this指向的是这个对象")]),s._v(" "),t("li",[s._v("箭头函数内部  this指向了当前作用域的最近一级外层作用域")]),s._v(" "),t("li",[s._v("new关键字将函数作为构造函数调用时，构造函数内部的this指向新创建的对象。")])])]),s._v(" "),t("li",[t("p",[s._v("三者相同点")]),s._v(" "),t("ul",[t("li",[s._v("call、apply、bind都是用来绑定函数执行时this指向，同时可以传参，调用它们的对象必须是一个函数Function")])])]),s._v(" "),t("li",[t("p",[s._v("三者不同点：区别主要体现在传参上")]),s._v(" "),t("ul",[t("li",[s._v("call可以传多个参数，第一个参数是this指向，其余参数是要传递的参数")]),s._v(" "),t("li",[s._v("apply，有两个参数，第一个是this指向，第二个是参数数组")]),s._v(" "),t("li",[s._v("bind可以传多个参数，第一个参数是this指向，其余参数是要传递的参数。bind方法的返回值是函数，需要手动调用才会执行")])])])]),s._v(" "),t("h2",{attrs:{id:"【6】什么是闭包-为什么要用它-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【6】什么是闭包-为什么要用它-掌握"}},[s._v("#")]),s._v(" 【6】什么是闭包？为什么要用它？（掌握）")]),s._v(" "),t("p",[s._v("闭包本质就是一个函数，它是指能够读取其他函数内部变量的函数，它是将函数内外部连接起来的桥梁。只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。")]),s._v(" "),t("p",[s._v("闭包的主要作用：实现了数据的私有化，延伸了变量的作用范围。")]),s._v(" "),t("h2",{attrs:{id:"【7】简述js继承的方式-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【7】简述js继承的方式-掌握"}},[s._v("#")]),s._v(" 【7】简述js继承的方式（掌握）")]),s._v(" "),t("ul",[t("li",[s._v("混入式继承：把父类的所有方法都拷贝到子类上")]),s._v(" "),t("li",[s._v("原型式继承：只继承父类原型上的属性和方法，")]),s._v(" "),t("li",[s._v("原型链继承：继承父类构造函数里边的属性和方法，也继承父类原型上的属性和方法 缺点--不能向父类传参数")]),s._v(" "),t("li",[s._v("借用构造函数继承：可以父类传递参数 缺点--继承不了父类原型对象的方法")]),s._v(" "),t("li",[s._v("组合继承：借用构造函数继承属性+原型链继承方法")])]),s._v(" "),t("h2",{attrs:{id:"【8】深拷贝和浅拷贝的区别-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【8】深拷贝和浅拷贝的区别-掌握"}},[s._v("#")]),s._v(" 【8】深拷贝和浅拷贝的区别（掌握）")]),s._v(" "),t("ul",[t("li",[s._v("深拷贝拷贝多层，每一级别的数据都会拷贝，像数组、对象内的数据都是可以拷贝的。")]),s._v(" "),t("li",[s._v("浅拷贝只是拷贝一层，像简单数据类型可以直接拷贝，更深层次对象级别的只拷贝对象引用地址（修改对象内的属性值会相互影响）")]),s._v(" "),t("li",[s._v("es6新增方法可以浅拷贝：Object.assign(新对象,被拷贝对象)")])]),s._v(" "),t("h2",{attrs:{id:"【9】如何实现深拷贝-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【9】如何实现深拷贝-掌握"}},[s._v("#")]),s._v(" 【9】如何实现深拷贝（掌握）")]),s._v(" "),t("p",[s._v("将对象转成字符串、字符串是深拷贝、将字符串转成对象")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 将对象转为字符串")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" str "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JSON")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("stringify")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 深拷贝")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" nstr "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" str\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 将字符串转为数组")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" nobj "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JSON")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("parse")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("nstr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//变成一行  深拷贝的方法")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" nnobj "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JSON")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("parse")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JSON")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("stringify")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("h2",{attrs:{id:"【10】javascript-的垃圾回收机制讲一下-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【10】javascript-的垃圾回收机制讲一下-掌握"}},[s._v("#")]),s._v(" 【10】javascript 的垃圾回收机制讲一下（掌握）")]),s._v(" "),t("ul",[t("li",[s._v("垃圾回收机制（Garbage Collection）简称GC")]),s._v(" "),t("li",[s._v("JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。")]),s._v(" "),t("li",[s._v("垃圾回收机制会自动在后台进行检查，哪些内存空间是已经没有被变量绑定的，如果存在就会标记它们，在垃圾回收执行时去释放这些标记好的内存空间的地址，这个释放并不是删除，而是告诉CPU哪些空间是可以用的，后续有新数据便会存入到里面，进行覆盖。")]),s._v(" "),t("li",[s._v("不再用到的内存，没有及时释放，就叫做内存泄露。垃圾回收机制就是防止内存泄漏的。")])]),s._v(" "),t("h2",{attrs:{id:"【11】介绍下-promise-的特性、优缺点-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【11】介绍下-promise-的特性、优缺点-掌握"}},[s._v("#")]),s._v(" 【11】介绍下 promise 的特性、优缺点（掌握）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("Promise是异步编程的一种解决方案，异步转同步（调用起来像同步一样）\n它的功能：避免了异步回调的多层嵌套，把异步代码改成调用起来像同步代码。")])]),s._v(" "),t("li",[t("p",[s._v("Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)")])]),s._v(" "),t("li",[t("p",[s._v("Promise优点")]),s._v(" "),t("ol",[t("li",[s._v("统一异步 API\nPromise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。")]),s._v(" "),t("li",[s._v("Promise 与事件对比\n和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。")]),s._v(" "),t("li",[s._v("Promise 与回调对比\n解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。")]),s._v(" "),t("li",[s._v("Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如Array.prototype.map() ）。")])])]),s._v(" "),t("li",[t("p",[s._v("Promise缺点")]),s._v(" "),t("ol",[t("li",[s._v("无法取消Promise，一旦新建它就会立即执行，无法中途取消。")]),s._v(" "),t("li",[s._v("如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。")]),s._v(" "),t("li",[s._v("当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")]),s._v(" "),t("li",[s._v("Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。")])])])]),s._v(" "),t("h2",{attrs:{id:"【12】请描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【12】请描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[s._v("#")]),s._v(" 【12】请描述一下 cookies，sessionStorage 和 localStorage 的区别？")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("cookie是网站为了标示用户身份而存储在用户本地终端上的数据，是加密的。")])]),s._v(" "),t("li",[t("p",[s._v("cookie数据始终在同源的http请求中携带，会在浏览器和服务器间来回传递。")])]),s._v(" "),t("li",[t("p",[s._v("sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存")])]),s._v(" "),t("li",[t("p",[s._v("存储大小")]),s._v(" "),t("ol",[t("li",[s._v("cookie数据大小不能超过4kb")]),s._v(" "),t("li",[s._v("sessionStorage和localStorage可以达到5M或更大")])])]),s._v(" "),t("li",[t("p",[s._v("有效时间")]),s._v(" "),t("ol",[t("li",[s._v("cookie可以设置过期时间，在没过期之前，一直有效，不会因窗口或浏览器的关闭受到影响")]),s._v(" "),t("li",[s._v("sessionStorage数据在当前浏览器窗口关闭后自动删除")]),s._v(" "),t("li",[s._v("localStorage浏览器关闭后数据不丢失，可以持久存储数据，除非手动删除")])])])]),s._v(" "),t("h2",{attrs:{id:"【13】简述同源策略与跨域-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【13】简述同源策略与跨域-掌握"}},[s._v("#")]),s._v(" 【13】简述同源策略与跨域（掌握）")]),s._v(" "),t("p",[s._v("同源策略是一种约定，它是浏览器最核心的也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。")]),s._v(" "),t("p",[s._v("当协议，主机，和端口号有一个不同时，就是跨域。")]),s._v(" "),t("h2",{attrs:{id:"【14】跨域解决方案-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【14】跨域解决方案-掌握"}},[s._v("#")]),s._v(" 【14】跨域解决方案（掌握）")]),s._v(" "),t("ul",[t("li",[s._v("网站跨域问题一般发生在前后端分离的架构。")]),s._v(" "),t("li",[s._v("解决方案\n"),t("ol",[t("li",[s._v("前后端部署到同一台web服务器，实现了同源策略。")]),s._v(" "),t("li",[s._v("（后端）服务器配置CORS(跨域资源共享)")]),s._v(" "),t("li",[s._v("（后端）node.js或Nginx，反向代理，把跨域改造成同域")]),s._v(" "),t("li",[s._v("（前端）将JSON升级成JSONP，在JSON的基础上，利用script 标签可以跨域的特性，加上头设置")])])])]),s._v(" "),t("h2",{attrs:{id:"【15】浏览器的事件循环-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【15】浏览器的事件循环-掌握"}},[s._v("#")]),s._v(" 【15】浏览器的事件循环（掌握）")]),s._v(" "),t("ul",[t("li",[s._v("主线程不断的重复获得任务，执行任务的过程被称为浏览器的事件循环。")]),s._v(" "),t("li",[s._v("JS语言特点是单线程，解释性语言，解释一行执行一行，也就是说同一时间只能做一件事。\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就得一直等待。")]),s._v(" "),t("li",[s._v("JS将所有任务分成两种，一种是同步任务，另一种是异步任务，异步任务又分为两种，宏任务和微任务。先执行宏任务，再执行微任务。\n"),t("ul",[t("li",[s._v("同步任务指的是，在主线程中排队执行的任务，按序执行，只有前一个任务执行完毕，才能执行后一个任务；")]),s._v(" "),t("li",[s._v("异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。")])])])]),s._v(" "),t("h2",{attrs:{id:"【16】什么是防抖和节流-有什么区别-如何实现-掌握"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【16】什么是防抖和节流-有什么区别-如何实现-掌握"}},[s._v("#")]),s._v(" 【16】什么是防抖和节流？有什么区别？如何实现？（掌握）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("防抖或节流：通过一定的方式去限制函数的执行次数")])]),s._v(" "),t("li",[t("p",[s._v("防抖：通过setTimeout的方式，在一定的时间间隔内，将多次触发变成一次触发。如果设定的时间还没到来之前，又一次触发了事件 ，则清除之前的定时器，就重新开始延时。")])]),s._v(" "),t("li",[t("p",[s._v("节流：在一段时间内，只执行一次某个操作；过了这一段时间，还有操作的话，继续执行新的操作")])]),s._v(" "),t("li",[t("p",[s._v("区别:")]),s._v(" "),t("ul",[t("li",[s._v("节流不管事件触发多频繁，都保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数")])])]),s._v(" "),t("li",[t("p",[s._v("实现：")]),s._v(" "),t("ul",[t("li",[s._v("防抖：每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。")]),s._v(" "),t("li",[s._v("节流：每次触发事件的时候，判断当前是否存在等待执行的延时函数")])])])]),s._v(" "),t("h2",{attrs:{id:"【17】给一个常量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【17】给一个常量"}},[s._v("#")]),s._v(" 【17】给一个常量")])])}),[],!1,null,null,null);t.default=_.exports}}]);