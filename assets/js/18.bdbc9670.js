(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{286:function(v,e,t){"use strict";t.r(e);var a=t(13),_=Object(a.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),e("h2",{attrs:{id:"【1】能说下-vue-router-中常用的路由模式实现原理吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【1】能说下-vue-router-中常用的路由模式实现原理吗"}},[v._v("#")]),v._v(" 【1】能说下 vue-router 中常用的路由模式实现原理吗")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("hash模式，兼容性好但是不美观")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。")])]),v._v(" "),e("li",[e("p",[v._v("可以为 hash 的改变添加监听事件")])])])]),v._v(" "),e("li",[e("p",[v._v("history模式，虽然美观，但是刷新后会出现404，需要后端进行配置")]),v._v(" "),e("p",[v._v("利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法")])])]),v._v(" "),e("h2",{attrs:{id:"【2】vue常用的修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【2】vue常用的修饰符"}},[v._v("#")]),v._v(" 【2】vue常用的修饰符？")]),v._v(" "),e("ul",[e("li",[v._v("事件修饰符\n"),e("ul",[e("li",[v._v(".stop 阻止事件冒泡")]),v._v(" "),e("li",[v._v(".prevent 阻止默认行为")]),v._v(" "),e("li",[v._v(".once 阻止事件重复触发")]),v._v(" "),e("li",[v._v(".self 当事件发生在该元素本身而不是子元素的时候会触发")]),v._v(" "),e("li",[v._v(".capture 事件侦听，事件发生的时候会调用")])])]),v._v(" "),e("li",[v._v("键盘修饰符\n"),e("ul",[e("li",[v._v("enter 回车")]),v._v(" "),e("li",[v._v("space 空格")])])]),v._v(" "),e("li",[v._v("表单修饰符\n"),e("ul",[e("li",[v._v("trim 去除两端空白符")]),v._v(" "),e("li",[v._v("number 将表单内容类型转为数字类型")])])])]),v._v(" "),e("h2",{attrs:{id:"【3】vue中v-if与v-show的区别以及使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【3】vue中v-if与v-show的区别以及使用场景"}},[v._v("#")]),v._v(" 【3】vue中v-if与v-show的区别以及使用场景")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，而v-show 元素总是会被渲染，只是简单地基于css进行切换")])]),v._v(" "),e("li",[e("p",[v._v("频繁的去控制元素的显示和隐藏 就 使用 v-show，反之运行条件很少改变就使用 v-if")])])]),v._v(" "),e("h2",{attrs:{id:"【4】v-if和v-for为什么避免一起用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【4】v-if和v-for为什么避免一起用"}},[v._v("#")]),v._v(" 【4】v-if和v-for为什么避免一起用")]),v._v(" "),e("p",[v._v("因为v-for具有比v-if更高的优先级，会先遍历再控制元素显示与销毁")]),v._v(" "),e("h2",{attrs:{id:"【5】使用过-vue-ssr-吗-说说-ssr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【5】使用过-vue-ssr-吗-说说-ssr"}},[v._v("#")]),v._v(" 【5】使用过 Vue SSR 吗？说说 SSR")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("SSR是服务端渲染，就是将在客户端的标签渲染成html的工作由服务端完成，然后直接将html在返回给客户端")])]),v._v(" "),e("li",[e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[v._v("更好的SEO、并且首屏加载快")])])]),v._v(" "),e("li",[e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[v._v("开发条件会受限制，服务器会有更大的负载需求")])])])]),v._v(" "),e("h2",{attrs:{id:"【6】你都做过哪些-vue-的性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【6】你都做过哪些-vue-的性能优化"}},[v._v("#")]),v._v(" 【6】你都做过哪些 Vue 的性能优化")]),v._v(" "),e("ul",[e("li",[v._v("不需要响应的数据不要放到data中（可以用Object.freeze()冻结数据）")]),v._v(" "),e("li",[v._v("v-if和v-show区分场景")]),v._v(" "),e("li",[v._v("computed和watch区分场景")]),v._v(" "),e("li",[v._v("图片懒加载")]),v._v(" "),e("li",[v._v("路由懒加载")]),v._v(" "),e("li",[v._v("第三方插件按需引入")]),v._v(" "),e("li",[v._v("防抖和节流的运用")]),v._v(" "),e("li",[v._v("适当采用keepAlive缓存组件")])]),v._v(" "),e("h2",{attrs:{id:"【7】keep-alive-使用场景和原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【7】keep-alive-使用场景和原理"}},[v._v("#")]),v._v(" 【7】keep-alive 使用场景和原理")]),v._v(" "),e("p",[v._v("keepAlive是vue中的一个内置组件，它可以在组件切换的时候保留状态，防止重复渲染DOM")]),v._v(" "),e("p",[v._v("可以使用 "),e("code",[v._v("$route")]),v._v(" 获取 meta 中的keepAlive的值来实现选择性保留状态")]),v._v(" "),e("ul",[e("li",[v._v("常用的两个属性 include/exclude，允许组件有条件的进行缓存。")]),v._v(" "),e("li",[v._v("两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。")]),v._v(" "),e("li",[v._v("keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。")])]),v._v(" "),e("h2",{attrs:{id:"【8】vue-set-方法原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【8】vue-set-方法原理"}},[v._v("#")]),v._v(" 【8】Vue.set 方法原理")]),v._v(" "),e("p",[v._v("了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的")]),v._v(" "),e("p",[v._v("1.在实例创建之后添加新的属性到实例上（给响应式对象新增属性）")]),v._v(" "),e("p",[v._v("2.直接更改数组下标来修改数组的值")]),v._v(" "),e("p",[v._v("Vue.set 或者说是$set 原理如下")]),v._v(" "),e("p",[v._v("因为响应式数据 我们给对象和数组本身都增加了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象__ob__的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组")]),v._v(" "),e("h2",{attrs:{id:"【9】多层父子组件通讯"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【9】多层父子组件通讯"}},[v._v("#")]),v._v(" 【9】多层父子组件通讯")]),v._v(" "),e("p",[v._v("provide/inject")]),v._v(" "),e("h2",{attrs:{id:"【10】父子组件通讯方式有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【10】父子组件通讯方式有哪些"}},[v._v("#")]),v._v(" 【10】父子组件通讯方式有哪些？")]),v._v(" "),e("p",[v._v("父传子:自定义属性props")]),v._v(" "),e("p",[v._v("子传父:自定义事件$emit")]),v._v(" "),e("p",[v._v("EventBus:事件总线")]),v._v(" "),e("h2",{attrs:{id:"【11】没有任何关系的组件传值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【11】没有任何关系的组件传值"}},[v._v("#")]),v._v(" 【11】没有任何关系的组件传值")]),v._v(" "),e("p",[v._v("vuex")]),v._v(" "),e("h2",{attrs:{id:"【12】简述vue的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【12】简述vue的生命周期"}},[v._v("#")]),v._v(" 【12】简述Vue的生命周期")]),v._v(" "),e("p",[v._v("Vue常用的生命周期有8个，都是成对出现的。")]),v._v(" "),e("p",[v._v("分别是 "),e("code",[v._v("创建前/后")]),v._v(" "),e("code",[v._v("挂载前/后")]),v._v(" "),e("code",[v._v("更新前/后")]),v._v(" "),e("code",[v._v("销毁前/后")])]),v._v(" "),e("h2",{attrs:{id:"【13】vue实现数据双向绑定的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【13】vue实现数据双向绑定的原理"}},[v._v("#")]),v._v(" 【13】Vue实现数据双向绑定的原理")]),v._v(" "),e("p",[v._v("采用Object.defineProperty进行数据劫持并结合发布者-订阅者模式的方式实现数据的双向绑定原理")]),v._v(" "),e("p",[v._v("借助 "),e("code",[v._v("Object.defineProperty()")]),v._v(" 对数据进行劫持，其中会有getter()和setter()方法；当读取属性值时，就会触发getter()方法，在view中如果数据发生了变化，就会通过 "),e("code",[v._v("Object.defineProperty()")]),v._v(" 对属性设置一个setter函数，当数据改变了就会来触发这个函数")]),v._v(" "),e("h2",{attrs:{id:"【14】vuex刷新页面数据丢失怎么解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【14】vuex刷新页面数据丢失怎么解决"}},[v._v("#")]),v._v(" 【14】Vuex刷新页面数据丢失怎么解决？")]),v._v(" "),e("p",[v._v("办法一：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）")]),v._v(" "),e("p",[v._v("办法二：在页面刷新的时候再次请求远程数据，使之动态更新vuex数据")]),v._v(" "),e("p",[v._v("办法三：在父页面向后台请求远程数据，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）")]),v._v(" "),e("p",[v._v("Vuex的数据是响应式的，一个地方改其他地方立马生效")]),v._v(" "),e("h2",{attrs:{id:"【15】简单讲述vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【15】简单讲述vuex"}},[v._v("#")]),v._v(" 【15】简单讲述vuex")]),v._v(" "),e("p",[v._v("Vuex是Vue.js中管理数据状态的一个库，我们可以将所有组件中的公共数据在Vuex中集中管理")]),v._v(" "),e("p",[v._v("Vuex的状态存储是响应式的")]),v._v(" "),e("p",[v._v("Vuex有5个属性")]),v._v(" "),e("ul",[e("li",[v._v("state：用于存放公共数据")]),v._v(" "),e("li",[v._v("getter：类似于计算属性，当值改变时自动触发")]),v._v(" "),e("li",[v._v("mutation：同步修改属性：用于修改state中的数据")]),v._v(" "),e("li",[v._v("action：异步修改属性，主要就是进行mutation的异步操作")]),v._v(" "),e("li",[v._v("module：模块管理\n"),e("ul",[e("li",[v._v("Vuex使用的是单一状态树，应用的所有状态会集中到一起，会形成一个比较大的对象，而且当应用变得非常复杂时，store对象就有可能变得非常臃肿，为了解决以上问题，Vuex允许我们将store分割成模块，这样就非常灵活，每个模块都有自己的state、getter、mutation、action")])])])]),v._v(" "),e("h2",{attrs:{id:"【16】vue-组件-data-为什么必须是函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【16】vue-组件-data-为什么必须是函数"}},[v._v("#")]),v._v(" 【16】Vue 组件 data 为什么必须是函数")]),v._v(" "),e("p",[v._v("data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。")]),v._v(" "),e("h2",{attrs:{id:"【17】nexttick-是做什么的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【17】nexttick-是做什么的"}},[v._v("#")]),v._v(" 【17】nextTick 是做什么的")]),v._v(" "),e("p",[e("code",[v._v("$nextTick")]),v._v(" 是在下次 "),e("code",[v._v("DOM")]),v._v(" 更新循环结束之后执行延迟回调，在修改数据之后使用 "),e("code",[v._v("$nextTick")]),v._v("，则可以在回调中获取更新后的DOM。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("DOM渲染完毕更新完毕会触发")])]),v._v(" "),e("li",[e("p",[v._v("可以写在任何一个生命周期中")]),v._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("created(){\n\tthis.$nextTick(()=>{\n\t\t获取DOM 100%能获取到\n\t\t一般情况下，不在这里获取DOM\n\t})\n}\n\nmounted(){\n\t直接获取DOM，操作\n}\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br"),e("span",{staticClass:"line-number"},[v._v("5")]),e("br"),e("span",{staticClass:"line-number"},[v._v("6")]),e("br"),e("span",{staticClass:"line-number"},[v._v("7")]),e("br"),e("span",{staticClass:"line-number"},[v._v("8")]),e("br"),e("span",{staticClass:"line-number"},[v._v("9")]),e("br"),e("span",{staticClass:"line-number"},[v._v("10")]),e("br")])])])]),v._v(" "),e("h2",{attrs:{id:"【18】-route-和-router-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【18】-route-和-router-的区别"}},[v._v("#")]),v._v(" 【18】"),e("code",[v._v("$route")]),v._v(" 和 "),e("code",[v._v("$router")]),v._v(" 的区别")]),v._v(" "),e("p",[e("code",[v._v("$route")]),v._v(" 为当前 "),e("code",[v._v("router")]),v._v(" 跳转对象里面可以获取 "),e("code",[v._v("name")]),v._v(" 、 "),e("code",[v._v("path")]),v._v(" 、 "),e("code",[v._v("query")]),v._v(" 、 "),e("code",[v._v("params")]),v._v(" 等")]),v._v(" "),e("p",[e("code",[v._v("$router")]),v._v(" 为 "),e("code",[v._v("VueRouter")]),v._v(" 实例，想要导航到不同 "),e("code",[v._v("URL")]),v._v("，则使用 "),e("code",[v._v("$router.push")]),v._v(" 方法")]),v._v(" "),e("h2",{attrs:{id:"【19】virtual-dom-虚拟dom-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【19】virtual-dom-虚拟dom-是什么"}},[v._v("#")]),v._v(" 【19】Virtual DOM（虚拟DOM）是什么？")]),v._v(" "),e("p",[v._v("Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实的DOM上")]),v._v(" "),e("h2",{attrs:{id:"【20】为何需要virtual-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【20】为何需要virtual-dom"}},[v._v("#")]),v._v(" 【20】为何需要Virtual DOM？")]),v._v(" "),e("h2",{attrs:{id:"【21】virtual-dom的diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【21】virtual-dom的diff算法"}},[v._v("#")]),v._v(" 【21】Virtual DOM的diff算法")]),v._v(" "),e("h2",{attrs:{id:"【22】修改第三方库的样式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【22】修改第三方库的样式"}},[v._v("#")]),v._v(" 【22】修改第三方库的样式")]),v._v(" "),e("p",[v._v("/deep/")]),v._v(" "),e("h2",{attrs:{id:"【23】computed和watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【23】computed和watch"}},[v._v("#")]),v._v(" 【23】Computed和Watch")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("计算属性需要调用，并且调用书不加()，而监听函数无需调用")])]),v._v(" "),e("li",[e("p",[v._v("计算属性是通过它依赖的属性发生变化后得到的值，并且数据结果会被缓存，且函数中必须通过return返回最终的结果，而监听函数监听的是属性的变化，拿变化后的属性去做后续的操作")])]),v._v(" "),e("li",[e("p",[v._v("使用场景：")]),v._v(" "),e("ul",[e("li",[v._v("当一个结果受多个属性影响的时候就需要使用计算属性")]),v._v(" "),e("li",[v._v("当一个数据的变化参与到后续操作的时候需要使用监听函数")])])])]),v._v(" "),e("h2",{attrs:{id:"【24】vuex的应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【24】vuex的应用场景"}},[v._v("#")]),v._v(" 【24】Vuex的应用场景")])])}),[],!1,null,null,null);e.default=_.exports}}]);